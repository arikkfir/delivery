name: Deploy to Environment
on:
  workflow_call:
    inputs:
      branch:
        type: string
        description: |
          Source branch being deployed to this environment. This will be used, after being "slugged", to infer the
          target environment to deploy the list of images provided in the `images` input.
        required: true
      images:
        type: string
        description: |
          Map of images to deploy, in YAML format of "image: tag" pairs, for example:

          ```
          my-image: newTag
          my-2nd-image: new2ndTag
          ```

          This MUST be a valid YAML object - thus the space after the `:` character is crucial.
        required: true
defaults:
  run:
    shell: bash -exuo pipefail {0}
env:
  FLUXCD_VERSION: 2.1.0
  GCP_CLI_VERSION: 443.0.0
  GCP_SERVICE_ACCOUNT: delivery@arikkfir.iam.gserviceaccount.com
  GCP_WORKLOAD_IDENTITY_PROVIDER: projects/8909046976/locations/global/workloadIdentityPools/github-actions/providers/github-oidc
  GKE_CLUSTER_NAME: main
  GKE_CLUSTER_LOCATION: me-west1-a
jobs:
  commit:
    name: Commit
    runs-on: ubuntu-22.04
    permissions:
      contents: write
    outputs:
      env: ${{ steps.env.outputs.name }}
    steps:
      - uses: actions/checkout@v3
        with:
          repository: arikkfir/delivery
          token: ${{ secrets.ARIKKFIR_GHA_AUTOMATION }} # Required since this workflow is called by other repositories
      - uses: arikkfir/delivery-env-name@v1
        id: env
        with:
          branch: ${{ inputs.branch }}
      - run: |
          # Ensure Flux kustomization file and Kustomize kustomization files exist
          [[ -f "${FLUX_K_FILE}" ]] || cat etc/env-flux-kustomization-template.yaml | envsubst > "${FLUX_K_FILE}"
          [[ -f "${K_FILE}" ]] || (mkdir -pv "$(dirname "${K_FILE}")" && cat etc/env-kustomization-template.yaml | envsubst > "${K_FILE}")

          # Ensure they have the "images" and "patches" properties; create them if missing with empty values
          [[ "$(yq e '.images == null' "${K_FILE}")" == "false" ]] || yq e -i '.images = []' "${K_FILE}"
          [[ "$(yq e '.patches == null' "${K_FILE}")" == "false" ]] || yq e -i '.patches = []' "${K_FILE}"

          # For non-main environments, ensure the "resources" property is set by default to extend the "main" variant,
          # and also ensure it's missing the stale-environments patches (since we're deploying to it, it's not stale)
          if [[ "${ENV_NAME}" != "main" ]]; then
            [[ "$(yq e '.resources == null' "${K_FILE}"))" == "false" ]] || yq e -i '.resources = ["../main"]' "${K_FILE}"
            yq e -i '.patches -= load("etc/stale-env-patches.yaml")' "${K_FILE}"
          fi

          # Dump the given new images map into a YAML file
          # TODO: make sure it's a valid object; common when source caller does not put a space after the ":" separator
          cat > new-images.yaml <<EOF
          ${{ inputs.images }}
          EOF

          # Merge the existing images in the environment kustomization with the newly given images map
          # This requires first converting the existing images array into a map, performing the merge, and then store
          # the result back into the kustomization "images" property
          # Detailed explanation:
          #   . ref $k                                                  -> save current object (the kustomization) as variable "k"
          #   | .images[] as $i ireduce( {}; .[$i|.name]=($i|.newTag) ) -> reduce images array to an object; key is image name, value is image tag
          #   | . * load("new-images.yaml")                             -> merge the new images map into the images object (new overriding old images)
          #   | to_entries                                              -> translate the final images object to an array
          #   | map({"name":.key,"newTag":.value})                      -> shape the array to the expected kustomize images structure
          #   | $k.images = .                                           -> store the current context (".") which is the final images array into the "images" property in "k"
          #   | $k                                                      -> return "k"
          yq e -i '. ref $k | .images[] as $i ireduce( {}; .[$i|.name]=($i|.newTag) ) | . * load("new-images.yaml") | to_entries | map({"name":.key,"newTag":.value}) | $k.images = . | $k' "${K_FILE}"
        env:
          ENV_NAME: ${{ steps.env.outputs.name }}
          FLUX_K_FILE: clusters/${{ env.GKE_CLUSTER_NAME }}/environments/${{ steps.env.outputs.name }}.yaml
          K_FILE: environments/${{ steps.env.outputs.name }}/kustomization.yaml
      - uses: EndBug/add-and-commit@v9
        with:
          add: clusters/*/environments/*.yaml environments/*/kustomization.yaml
          author_name: GitHub Actions
          author_email: <delivery@kfirs.com>
          message: |
            Deployment to "${{ steps.env.outputs.name }}" from "${{ github.repository }}"

            Environment:       ${{ steps.env.outputs.name }}
            Source repository: ${{ github.repository }}
            Branch:            ${{ inputs.branch }}
  verify:
    name: Wait for environment readiness
    needs: commit
    runs-on: ubuntu-22.04
    permissions:
      id-token: write
    steps:
      - uses: actions/checkout@v3
        with:
          repository: arikkfir/delivery
          token: ${{ secrets.ARIKKFIR_GHA_AUTOMATION }}
      - uses: google-github-actions/auth@v1
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
      - uses: google-github-actions/setup-gcloud@v1
        with:
          install_components: gke-gcloud-auth-plugin
          version: ${{ env.GCP_CLI_VERSION }}
      - uses: google-github-actions/get-gke-credentials@v0
        with:
          cluster_name: ${{ env.GKE_CLUSTER_NAME }}
          location: ${{ env.GKE_CLUSTER_LOCATION }}
      - uses: fluxcd/flux2/action@main
        with:
          version: ${{ env.FLUXCD_VERSION }}
      - run: flux --timeout 30m0s reconcile -n default kustomization env-${ENVIRONMENT}
        env:
          ENVIRONMENT: ${{ needs.commit.outputs.env }}
