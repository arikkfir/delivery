name: Deploy to Environment
on:
  workflow_call:
    inputs:
      branch:
        type: string
        description: |
          Source branch being deployed to this environment. This will be used, after being "slugged", to infer the
          target environment to deploy the list of images provided in the `images` input.
        required: true
      images:
        type: string
        description: |
          Map of images to deploy, in YAML format of "image: tag" pairs, for example:

          ```
          my-image: newTag
          my-2nd-image: new2ndTag
          ```

          This MUST be a valid YAML object - thus the space after the `:` character is crucial.
        required: true
defaults:
  run:
    shell: bash -exuo pipefail {0}
env:
  FLUXCD_VERSION: 2.1.0
  GCP_CLI_VERSION: 443.0.0
  GCP_SERVICE_ACCOUNT: delivery@arikkfir.iam.gserviceaccount.com
  GCP_WORKLOAD_IDENTITY_PROVIDER: projects/8909046976/locations/global/workloadIdentityPools/github-actions/providers/github-oidc
  GKE_CLUSTER_NAME: main
  GKE_CLUSTER_LOCATION: me-west1-a
jobs:
  commit:
    name: Commit
    runs-on: ubuntu-22.04
    permissions:
      contents: write
    outputs:
      env: ${{ steps.env.outputs.name }}
    steps:
      - uses: actions/checkout@v3
        with:
          repository: arikkfir/delivery
          token: ${{ secrets.ARIKKFIR_GHA_AUTOMATION }} # Required since this workflow is called by other repositories
      - uses: arikkfir/delivery-env-name@v1
        id: env
        with:
          branch: ${{ inputs.branch }}
      - run: "# Ensure Flux kustomization file and Kustomize kustomization files exist\n[[ -f \"${FLUX_K_FILE}\" ]] || cat etc/env-flux-kustomization-template.yaml | envsubst > \"${FLUX_K_FILE}\"\n[[ -f \"${K_FILE}\" ]] || (mkdir -pv \"$(dirname \"${K_FILE}\")\" && cat etc/env-kustomization-template.yaml | envsubst > \"${K_FILE}\")\n\n# Ensure they have the \"images\" and \"patches\" properties; create them if missing with empty values \n[[ \"$(yq e '.images == null' \"${K_FILE}\")\" == \"false\" ]] || yq e -i '.images = []' \"${K_FILE}\"\n[[ \"$(yq e '.patches == null' \"${K_FILE}\")\" == \"false\" ]] || yq e -i '.patches = []' \"${K_FILE}\"\n\n# For non-main environments, ensure the \"resources\" property is set by default to extend the \"main\" variant,\n# and also ensure it's missing the stale-environments patches (since we're deploying to it, it's not stale)\nif [[ \"${ENV_NAME}\" != \"main\" ]]; then\n  [[ \"$(yq e '.resources == null' \"${K_FILE}\"))\" == \"false\" ]] || yq e -i '.resources = [\"../main\"]' \"${K_FILE}\"\n  yq e -i '.patches -= load(\"etc/stale-env-patches.yaml\")' \"${K_FILE}\"\nfi\n\n# Dump the given new images map into a YAML file\n# TODO: make sure it's a valid object; common when source caller does not put a space after the \":\" separator\ncat > new-images.yaml <<EOF\n${{ inputs.images }}\nEOF\n\n# Merge the existing images in the environment kustomization with the newly given images map\n# This requires first converting the existing images array into a map, performing the merge, and then store\n# the result back into the kustomization \"images\" property\n# Detailed explanation:\n#   . ref $k                                                  -> save current object (the kustomization) as variable \"k\" \n#   | .images[] as $i ireduce( {}; .[$i|.name]=($i|.newTag) ) -> reduce images array to an object; key is image name, value is image tag\n#   | . * load(\"new-images.yaml\")                             -> merge the new images map into the images object (new overriding old images) \n#   | to_entries                                              -> translate the final images object to an array\n#   | map({\"name\":.key,\"newTag\":.value})                      -> shape the array to the expected kustomize images structure\n#   | $k.images = .                                           -> store the current context (\".\") which is the final images array into the \"images\" property in \"k\"\n#   | $k                                                      -> return \"k\"\nyq e -i '. ref $k | .images[] as $i ireduce( {}; .[$i|.name]=($i|.newTag) ) | . * load(\"new-images.yaml\") | to_entries | map({\"name\":.key,\"newTag\":.value}) | $k.images = . | $k' \"${K_FILE}\"\n"
        env:
          ENV_NAME: ${{ steps.env.outputs.name }}
          FLUX_K_FILE: clusters/${{ env.GKE_CLUSTER_NAME }}/environments/${{ steps.env.outputs.name }}.yaml
          K_FILE: environments/${{ steps.env.outputs.name }}/kustomization.yaml
      - uses: EndBug/add-and-commit@v9
        with:
          add: clusters/${{ env.GKE_CLUSTER_NAME }}/environments/${{ steps.env.outputs.name }}.yaml environments/${{ steps.env.outputs.name }}/kustomization.yaml
          author_name: GitHub Actions
          author_email: <delivery@kfirs.com>
          message: |
            Deployment to "${{ steps.env.outputs.name }}" from "${{ github.repository }}"

            Environment:       ${{ steps.env.outputs.name }}
            Source repository: ${{ github.repository }}
            Branch:            ${{ inputs.branch }}
  verify:
    name: Wait for environment readiness
    needs: commit
    runs-on: ubuntu-22.04
    permissions:
      id-token: write
    steps:
      - uses: actions/checkout@v3
        with:
          repository: arikkfir/delivery
          token: ${{ secrets.ARIKKFIR_GHA_AUTOMATION }}
      - uses: google-github-actions/auth@v1
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
      - uses: google-github-actions/setup-gcloud@v1
        with:
          install_components: gke-gcloud-auth-plugin
          version: ${{ env.GCP_CLI_VERSION }}
      - uses: google-github-actions/get-gke-credentials@v0
        with:
          cluster_name: ${{ env.GKE_CLUSTER_NAME }}
          location: ${{ env.GKE_CLUSTER_LOCATION }}
      - uses: fluxcd/flux2/action@main
        with:
          version: ${{ env.FLUXCD_VERSION }}
      - run: flux --timeout 30m0s reconcile -n default kustomization env-${ENVIRONMENT}
        env:
          ENVIRONMENT: ${{ needs.commit.outputs.env }}
